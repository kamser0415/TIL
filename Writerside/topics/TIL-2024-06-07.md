# MySQL 인덱스,B-tree
  
오늘은 다음주 스터디에서 인덱스를 발표하기에 MySQL 인덱스와 B-tree 구조를 공부했습니다.  
  
디스크 입출력 속도와 주 기억장치의 속도 차이로 인해 병목현상이 발생합니다.  
디스크 입출력 방식을 설명하면, A4 용지에 위에서 차례대로 입력하고 조회하는 방식은 순차 I/O 라고하며, 
용지 앞장 뒷장 이동하면서 기록하고 조회하는 걸 랜덤 I/O라고 합니다.  
  
당연히 랜덤 I/O가 순차 I/O에 비해 속도가 3~5배 정도 느리기 때문에 랜덤 I/O를 순차 I/O로 변경하는 방법은 어렵기 때문에 
디스크 입출력을 최소화하는 방식을 쿼리 튜닝이라고 합니다.  
  
데이터베이스는 디스크의 입출력을 최소화하기 위해 인덱스를 활용합니다.  
  
인덱스는 키와 값인 구조로 칼럼값을 그래도 매핑한것을 B-tree 인덱스라고 하며,
키를 해시 함수로 변환후 버킷에 저장하여 관리하는 방식을 Hash 인덱스라고 합니다.  
  
Btree 인덱스는 캍럼 값을 그대로 사용하기에 범위 검색이 가능하다는 것이 장점이며,
Hash 인덱스는 키값이 정확해야 조회가 가능하다는 한계가 있지만 빠른 조회가 가능하다는 장점이 있습니다.  
  
MySQL은 B-tree,Hash 방식을 모두 사용하며, 기본적인 인덱스는 B-tree 방식을 사용합니다.  
B-tree는 트리 구조로 이진 트리와 다르게 인덱스의 크기에 따라 자식 트리의 개수가 달라지며, 
인덱스의 크기가 클 수록 자식 트리의 개수가 감소하여 트리 깊이가 깊어지게 될 수 있고 속도 저하가 발생합니다.  
  
인덱스를 사용하는건 별도의 인덱스 파일을 추가로 사용하기 때문에 테이블의 25% 이상을 조회하는 경우라면 테이블 풀스캔이 더 나은 방법일 수 있습니다.  
   
인덱스를 효율적으로 사용한다는 건 레인지 인덱스 스캔, 루스 인덱스 스캔, 커버링 인덱스 스캔, 인덱스 스킵 스캔을 사용하는 것을 
말합니다.  

그러면 인덱스를 효율적으로 사용하기 위해선 왼쪽으로부터 적용되기 때문에 중간이나 데이터를 변환하여 비교할 경우 인덱스 적용되지 않습니다.  
  
인덱스 가용성을 높이기 위해서는 동등 비교 (=, IN), 비교 ( > , <), LIKE 'name%'으로 조건으로 사용해야하며,
MySQL은 다른 RDBMS와 다르게 NULL도 인덱스에 포함됩니다.  
  
인덱스 효율성을 높이기 위해선 작업 범위 결정 조건이 중요합니다. 
작업 범위 결정 조건이란 데이터 조회의 범위를 줄여주는 인덱스를 말하며, 필터링 조건은 조회이후 조건에 일치여부를 판단하는 걸 말합니다.  

## 오늘의 학습
+ 만족도 8/10
+ 사유 : 퇴근후 스터디 카페에서 집중력 있게 했지만, 피곤하여 중간에 졸았습니다.

## 06월 08일 목표
+ QUIZ 마무리하기 (코드 작성)
+ 자바의 신 복습
+ 이력서에 넣을만한 프로젝트 찾아보기