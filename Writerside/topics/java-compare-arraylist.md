# ArrayList 자료구조

## 내부 구조와 동작 원리

`ArrayList`는 자바에서 동적 배열을 구현한 클래스입니다. 내부적으로 `ArrayList`는 배열을 사용하여 요소들을 저장합니다. 주요 구성 요소는 다음과 같습니다:

- **배열**: 내부적으로 `Object[]` 배열을 사용하여 요소를 저장합니다.
- **크기(size)**: 현재 저장된 요소의 개수를 나타냅니다.
- **용량(capacity)**: 배열의 실제 크기를 나타내며, 배열의 길이를 의미합니다.

`ArrayList`의 동작 원리는 다음과 같습니다:

- **초기화**: `ArrayList`는 초기 용량을 가지고 생성됩니다. 기본 초기 용량은 10입니다.
- **요소 추가**: 요소를 추가할 때, 현재 크기(size)가 용량(capacity)보다 작으면 배열의 빈 공간에 요소를 추가하고 크기를 증가시킵니다.
- **요소 접근**: 인덱스를 이용하여 배열의 특정 위치에 있는 요소에 접근할 수 있습니다.
- **요소 삭제**: 특정 인덱스의 요소를 삭제하면 뒤에 있는 요소들을 앞으로 이동시키고 크기를 감소시킵니다.

## resizing 과정

`ArrayList`에 요소를 추가할 때 배열의 크기가 부족해지면, 새로운 더 큰 배열을 할당하고 기존 요소들을 복사하는 과정을 수행합니다. 이 과정은 다음과 같이 이루어집니다:

1. **크기 확인**: 요소를 추가하기 전에 현재 크기(size)가 용량(capacity)보다 작은지 확인합니다.
2. **용량 증가**: 현재 배열의 용량이 부족하면 새 배열의 크기를 결정합니다. 일반적으로 새 배열의 크기는 기존 배열 크기의 1.5배 또는 2배로 설정됩니다.
3. **새 배열 할당**: 새 배열을 할당하고 기존 배열의 요소들을 새 배열로 복사합니다.
4. **배열 참조 변경**: 내부 배열 참조를 새 배열로 변경합니다.
5. **요소 추가**: 새 배열에 요소를 추가합니다.

## 시간 복잡도

`ArrayList`의 resizing 과정의 시간 복잡도는 배열의 요소를 새 배열로 복사하는 데 소요되는 시간에 의해 결정됩니다. 배열 크기가 n인 경우, 복사 작업의 시간 복잡도는 O(n)입니다.

## 동적 배열의 amortized cost 개념

동적 배열의 amortized cost(평균 비용) 개념은 많은 삽입 연산을 수행할 때 각 연산의 평균 시간을 계산하는 방법입니다. 동적 배열에서 요소를 추가하는 연산의 amortized cost를 이해하기 위해, 배열의 크기 조절이 발생하는 경우와 그렇지 않은 경우를 나눠서 분석합니다.

- **상수 시간 삽입**: 배열에 여유 공간이 있는 경우, 요소 추가 연산은 상수 시간 O(1)에 수행됩니다.
- **크기 조절 비용**: 배열의 크기가 가득 차면 크기를 두 배로 늘리고 모든 요소를 새로운 배열로 복사하는 데 O(n)의 시간이 소요됩니다.

이제 전체 비용을 분석해 보겠습니다.

## Amortized Analysis

동적 배열에서 n개의 요소를 추가하는 과정을 생각해 봅시다. 배열이 가득 차서 크기를 조절하는 과정의 비용은 배열의 크기에 비례합니다. 예를 들어, 초기 크기가 1인 배열이 있다고 가정하면, 배열이 가득 찰 때마다 다음과 같은 과정이 반복됩니다:

1. **첫 번째 삽입**: 배열 크기 1, 비용 O(1).
2. **두 번째 삽입**: 배열 크기 2로 증가, 비용 O(2).
3. **네 번째 삽입**: 배열 크기 4로 증가, 비용 O(4).
4. **여덟 번째 삽입**: 배열 크기 8로 증가, 비용 O(8).

이러한 과정에서 n개의 요소를 추가하는 총 비용을 계산해 보면:

- 1 + 2 + 4 + 8 + ... + n/2

이 합은 기하급수적 시리즈로서, 최종 합은 약 2n에 가깝습니다. 따라서 총 비용은 2n입니다. n개의 요소를 추가하는 총 비용을 n으로 나누면 각 삽입 연산의 평균 비용은 O(1)입니다.

이로써 `ArrayList`의 요소 추가 연산의 amortized cost가 O(1)로 유지됩니다.

## 장점, 한계

### 사용하는 이유

1. **동적 크기 조절**: 일반적인 배열은 고정 크기이지만, `ArrayList`는 요소를 추가할 때 자동으로 크기를 조절하여 더 많은 데이터를 저장할 수 있습니다.
2. **간편한 사용**: 요소 추가, 삭제, 접근이 간편하며, 인덱스를 이용한 요소 접근이 상수 시간 O(1)으로 빠릅니다.
3. **유연성**: 데이터의 크기를 사전에 알 수 없을 때 유연하게 사용할 수 있으며, 데이터의 삽입과 삭제가 빈번한 경우 유용합니다.

### 장점

1. **빠른 요소 접근**: 인덱스를 사용하여 요소에 접근하는 속도가 빠릅니다. (상수 시간 O(1))
2. **자동 크기 조절**: 내부적으로 크기를 자동으로 조절하므로 사용자가 직접 크기를 관리할 필요가 없습니다.
3. **직관적인 사용법**: 직관적인 API로 요소 추가, 삭제, 검색 등을 쉽게 수행할 수 있습니다.

### 한계

1. **비효율적인 삽입과 삭제**: 중간에 요소를 삽입하거나 삭제할 경우, 해당 요소 이후의 모든 요소를 이동시켜야 하므로 시간 복잡도가 O(n)입니다.
2. **메모리 낭비 가능성**: 미리 큰 용량을 할당할 경우, 사용하지 않는 공간이 생겨 메모리가 낭비될 수 있습니다.
3. **동기화 문제**: `ArrayList`는 동기화되지 않기 때문에, 멀티스레드 환경에서는 `Vector` 또는 `Collections.synchronizedList`를 사용해야 합니다.

## 결론

동적 배열의 amortized cost 개념은 배열의 크기 조절 비용을 여러 삽입 연산에 걸쳐 분산시켜, 평균 시간 복잡도를 상수 시간 O(1)로 유지하는 것입니다. 이는 동적 배열의 효율성을 이해하고 평가하는 데 중요한 역할을 합니다. Amortized analysis는 이와 같이 특정 연산의 최악의 경우 시간 복잡도가 높은 경우에도, 전체적인 평균 성능을 평가할 수 있는 유용한 방법입니다.

`ArrayList`는 배열의 고정 크기 문제를 해결하고, 데이터 추가 및 삭제를 더 유연하게 처리할 수 있도록 설계되었습니다. 그러나 삽입 및 삭제의 비효율성과 동기화 문제 등의 한계도 존재하므로, 사용 환경과 요구 사항에 맞게 적절히 선택하는 것이 중요합니다.