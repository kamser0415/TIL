# B-tree

## 정의
`B-tree`는 주로 디스크 I/O를 최소화하고 대용량 데이터베이스의 효율성을 높이기 위해 설계된 균형 잡힌 다중 경로 탐색 트리입니다. 각 노드는 여러 개의 키와 자식 노드를 가질 수 있으며, 이는 노드 접근 시간을 줄이고 검색, 삽입, 삭제 연산을 효율적으로 수행할 수 있도록 합니다.

## 등장배경
1. 이진 트리의 최대 자식 노드의 개수 제한
2. 디스크 기반 자료구조가 필요

## 키워드
1. 루트노드, 내부노드, 리프노드
2. 균형 트리 유지
3. 페이지와 블록
4. 노드의 분할과 병합
5. 차수와 키 관계

## 규칙
자료구조는 데이터를 효율적으로 관리하기 위해 규칙이 필요합니다. 
B-tree는 이진 탐색 트리에서 발전된 자료구조로 기본적인 이진 트리의 규칙을 적용합니다.  

### 이진 탐색 트리 규칙
+ 규칙 1: 현재 노드를 기준으로 왼쪽 서브 트리는 작은 값이 저장되고, 오른쪽 서브트리 큰 값이 저장된다.
+ ~~규칙 2: 자녀 노드는 최대 두 개까지 갖는다.~~
  
### B-tree 규칙
**_자녀 노드의 최대 개수를 알아야 부모 노드의 key의 개수도 결정된다._**

+ **`M`** : 각 노드의 최대 자녀 노드 수 "M 차 B-tree라고 한다."
+ **`M-1`** :  각 노드의 key 수 (M이 결정되면 자연스럽게 결정된다.)
+ **`M/2`** :  각 노드의 최소 자녀의 노드 수* (올림) - 내부 노드 해당
+ **`[M/2] -1`** :각 노드의 최소 KEY 수 - 내부 노드, 리프노드 해당
  
예를 들어
: 
5차 B-tree 일 경우 
+ 최대 자식 노드의 수는 5개
+ 노드의 최대 key의 수는 4개
+ 노드의 자식 최소 노드의 수는 3개 `5/2 올림`
+ 노드의 최소 key의 개수는 2개
  
#### 규칙
+ 규칙 1: internal 노드의 key의 수가 x 개라면 자식 노드의 수는 언제나 x+1 이다.
  + 규칙 1 위반 예시: 부모 노드 키 2개, 자녀 노드 수 2개
+ 규칙 2: 노드가 최소 하나의 key를 가지기 때문에 차수 상관없이 internal 노드는 최소 2개의 자식 노드를 갖는다.
  + 차수가 정해지면 root 노드를 제외하고 internal 노드는 최소 `[M/2]`개의 자식 노드를 가져야한다.
  + 예시: 5차 B-tree 일 때, `(5/2) 올림 => 3` internal 노드는 최소 자식 노드를 3개를 가져야한다.
+ 규칙 3: key 추가/삭제는 항상 리프 노드에서 한다.
+ 규칙 4: 데이터 추가로 노드 key가 넘치면 가운데(median) key를 기준으로 좌우 key는 분할하여 각각 새 노드를 만들고 가운데 key는 상위 노드로 승진한다.
+ 규칙 5: 데이터 삭제 후 노드의 최소 key의 개수인 `M/2 -1` 수보다 적다면 재조정한다.

## 동작방식
+ [B-tree 동작 방식](https://www.cs.usfca.edu/~galles/visualization/BTree.html)
  
### 추가할 경우
3차 B-tree에서 key를 추가할 경우 동작 방식입니다.
:
+ 최대 자식 노드의 수는 3개
+ 최소 자식 노드의 수는 2개
+ 최대 노드의 key의 개수는 2개
+ 최소 노드의 key의 개수는 1개

위 조건으로 규칙을 작성해보면 다음과 같습니다.
+ key 추가는 항상 리프노드에서 한다.
+ key 추가로 최대 노드의 key의 개수(`2`)개를 넘으면 가운데(`median`) key는 상위노드로 승진한다.
+ 내부 노드의 최대 key의 개수는 2개, 최소는 1개다.
+ 내부 노드의 최소 자식 노드의 개수는 2개다.

**key 1 -> 15 -> 2 추가시**  
노드 내의 key들은 정렬되어 저장됩니다. 현재 key의 개수가 3개로 최대 key의 개수를 초과하여 가운데 key인 `2`를 상위 노드로 승진합니다.
상위 노드가 없으므로 새로운 노드를 만들어줍니다.  

<p align="center">
   <img src="btree-insert-ex-1.png" alt="Image 1" width="120" style="inline"/> >
   <img src="btree-insert-ex-2.png" alt="Image 2" width="120" style="inline"/> >
   <img src="btree-insert-ex-3.png" alt="Image 3" width="120" style="inline"/> >
   <img src="btree-insert-ex-4.png" alt="Image 3" width="120" style="inline"/>
</p>

****

****  



### 삭제할 경우

### 변경할 경우

## 특징
1. 모든 리프 노드는 같은 레벨에 있다.
    + `B-tree`가 균형 잡힌 트리이며, 모든 리프 노드가 동일한 깊이에 위치함으로써 탐색, 삽입, 삭제 작업의 일관된 성능을 보장합니다.
2. 시간 복잡도는 항상 O(log N)이다.
    + `B-tree`는 균형을 유지하기 때문에 탐색, 삽입, 삭제의 최악의 경우 시간 복잡도가 O(log N)으로 일정합니다. 여기서 N은 트리의 키 개수입니다.
3. 노드가 여러 키와 자식 포인터를 가질 수 있다.
    + `B-tree`는 각 노드는 최대 M개의 자식을 가질 수 있으며, M차 `B-tree`라고 합니다. 이로 인해 노드가 메모리 블록에 효율적으로 저장될 수 있습니다.
4. 키의 분포가 균등하게 유지된다.
    + 삽입과 삭제 작업 후에도 `B-tree`는 균형을 유지하며, 모든 노드가 반쯤 채워져 있음을 보장합니다. 이는 디스크 접근 횟수를 최소화하는 데 유리합니다.
5. 높은 자식 노드 수로 낮은 높이 유지
    + `B-tree`의 노드는 다수의 자식을 가질 수 있기에 트리의 높이가 낮게 유지됩니다. 이는 탐색과 같은 작업에서의 디스크 I/O 횟수를 줄이는 데 기여합니다.
    + 예: MySQL 기준 ( 키: 16바이트, 데이터포인트: 12바이트 ) 일시 `16*1024/(16+12)=585`로 노드당 585개 키를 보유할 수 있으므로 자식 노드는 586개를 갖을 수 있습니다.
6. 효율적인 범위 쿼리 지원
    + B-tree는 범위 쿼리에 매우 효율적이며, 정렬된 순서로 키를 저장하기 때문에 범위 내의 모든 키를 빠르게 검색할 수 있습니다.
7. 디스크 기반 자료구조에 최적화
    + B-tree는 디스크 접근을 최소화하는 데 최적화되어있어 데이터베이스와 파일 시스템에서 효과적으로 사용됩니다.
    + 블록 단위로 데이터를 읽고 쓰는 디스크의 특성에 맞춘 설게이기 때문입니다.

## 한계
