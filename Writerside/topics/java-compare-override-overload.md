# 오버로딩과 오버라이딩 정의 및 차이점

## 오버로딩 (Overloading)
- **정의**: 같은 메소드명을 가지고 매개변수의 개수나 타입이 다른 여러 메소드를 정의하는 것을 말합니다. 이는 컴파일러가 메소드 호출 시 전달되는 파라미터의 개수나 타입을 분석하여 어떤 메소드를 호출할지 결정합니다.
- **목적**: 메소드의 이름을 일관되게 유지하면서 다양한 입력을 처리할 수 있도록 하여 코드의 가독성과 유지보수성을 높입니다.

## 오버라이딩 (Overriding)
- **정의**: 상위 클래스가 가지고 있는 메소드를 하위 클래스에서 같은 시그니처(메소드 이름, 매개변수의 개수와 타입)로 재정의하여 사용하는 것을 말합니다. 이는 객체지향 프로그래밍의 다형성을 구현하는 기법 중 하나이며, 런타임 시 객체의 실제 타입에 따라 적당한 메소드가 호출됩니다.
- **목적**: 상속받은 메소드의 동작을 하위 클래스에 맞게 변경하여 재사용성을 높이고, 다형성을 통해 다양한 객체 타입을 일관된 인터페이스로 처리할 수 있게 합니다.

## 차이점
- **오버로딩**
    - 메소드명은 같지만 매개변수의 타입이나 개수가 달라야 합니다.
    - **컴파일 타임에 결정됩니다 (정적 바인딩)**.
    - 같은 클래스 내에서만 발생합니다.
- **오버라이딩**
    - 메소드명, 반환 타입, 매개변수의 타입과 개수가 모두 동일해야 합니다.
    - **런타임에 결정됩니다 (동적 바인딩)**.
    - 상위 클래스와 하위 클래스 간에 발생합니다.

## 바인딩과 성능 차이
- **정적 바인딩 (Static Binding)**
    - **컴파일 시점에** 어떤 메소드가 호출될지 결정됩니다.
    - 주로 오버로딩에 사용됩니다.
    - **빠릅니다**, 왜냐하면 컴파일러가 메소드 호출을 미리 결정하기 때문입니다.

- **동적 바인딩 (Dynamic Binding)**
    - **런타임 시점에** 어떤 메소드가 호출될지 결정됩니다.
    - 주로 오버라이딩에 사용됩니다.
    - **상대적으로 느립니다**, 왜냐하면 런타임에 객체의 실제 타입을 확인해야 하기 때문입니다.

## 코드 예시

### 오버로딩 예시
```java
public class Example {
    // 두 개의 정수를 더하는 메소드
    public int add(int a, int b) {
        return a + b;
    }

    // 세 개의 정수를 더하는 메소드
    public int add(int a, int b, int c) {
        return a + b + c;
    }

    // 두 개의 실수를 더하는 메소드
    public double add(double a, double b) {
        return a + b;
    }
}
```  

### 오버라이딩 예시
```Java
class Animal {
    // 동물이 소리를 내는 메소드
    public void makeSound() {
        System.out.println("Animal sound");
    }
}

class Dog extends Animal {
    // 개가 짖는 소리를 내는 메소드 (오버라이딩)
    @Override
    public void makeSound() {
        System.out.println("Woof");
    }
}
```