# 인덱스

> 전기적인 장치인 CPU나 RAM은 짧은 시간 내에 빠르게 발전했지만, 기계식 장치인 디스크의 성능 향상은 제한적이었습니다. 그 결과 데이터베이스의 성능 개선은 디스크 입출력(IO)를 최소화하는 방법에 중점이 맞춰지게 되었습니다.

## 디스크 입출력

디스크 입출력은 보조 기억장치에 데이터를 기록하고 조회하는 것을 말합니다. 데이터를 사용하기 위해 보조 기억장치에서 주 기억장치로 복사하는 과정이 필요한데, 주 기억장치(메모리)와 보조 기억장치(디스크)의 속도 차이로 인해 병목현상이 발생하게 됩니다.  
디스크는 메모리에 비해 접근 시간과 데이터 전송 속도가 상대적으로 느리기 때문에, 빈번한 디스크 I/O는 시스템 성능 저하의 주요 원인이 됩니다. 따라서 디스크 I/O를 최소화하는 것이 중요합니다.

### 순차, 랜덤 I/O

디스크를 A4 용지라고 생각하고 비교하면 아래와 같습니다.

1. **랜덤(Random I/O)**
    + A4용지 맨뒤에 데이터 A를 기록하고, 다시 손을 움직여 A4용지 맨 앞쪽에 데이터 B를 기록하고 다시 맨 뒤로 손을 움직여 데이터 C를 기록하는 방식입니다.

2. **순차(Sequential I/O)**
    + A4용지 앞장부터 아래로 차례대로 데이터 A, B, C를 기록하는 방식입니다.

손을 움직이는 시간을 디스크 헤드가 이동하는 시간이라고 생각하면 디스크에 데이터를 기록하고 읽을 때 발생하는 시간은 **디스크 헤드를 움직이는 시간에 따라 결정**됩니다.    
따라서 데이터베이스의 성능 튜닝은 디스크 I/O를 최소화하는 것이 중요합니다.

디스크에 파일 쓰기를 할 때 순차, 랜덤 방식 모두 반드시 동기화 작업이 필요합니다. 순차 방식이라도 빈번하게 파일 쓰기를 하는 경우 동기화 작업으로 인해 랜덤 I/O와 같이 비효율적인 형태로 처리가 될 때가 있습니다. 기업에서는 캐시 메모리가 장착된 `RAID 컨트롤러`를 사용합니다.

> RAID 컨트롤러란?
"Redundant Array of Inexpensive Drives"의 약어로, 캐시 메모리를 사용하여 성능을 최적화하고 디스크 I/O 작업을 줄이는 데 중점을 둡니다. InnoDB 스토리지 엔진의 버퍼풀과 유사합니다.

### 속도 개선 방법

랜덤 I/O를 순차 I/O로 바꿔서 실행하는 방법은 그다지 많지 않고, 일반적으로 랜덤 I/O 자체를 줄이는 것이 도움이 됩니다. 랜덤 I/O를 줄인다는 것은 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미합니다. 필요한 데이터만 빠르게 읽어올 수 있도록 설계된 것이 **인덱스**입니다.

### 운영환경 용어

+ **OLTP (OnLine Transaction Processing)**
    + 온라인 트랜잭션 처리라고 하며, 많은 트랜잭션을 처리하면서 한 번에 작은 데이터를 쓰거나 읽는 작업이 포함된 응용 프로그램을 말합니다. 예를 들어 예약 시스템이나 배달 애플리케이션 등이 이에 해당합니다.
    + 랜덤 I/O가 많습니다.

+ **데이터 웨어하우스 (Data Warehouse)**
    + 대규모 질의를 실행하는 응용 프로그램이나 데이터베이스 시스템을 말합니다. 데이터 웨어하우스는 주로 읽기 전용 또는 대부분 읽기 작업으로 이루어진 질의의 효율성을 위해 비정규화된 형태로 구성될 수 있습니다. 이는 OLTP와 대조적인 개념입니다.
    + 순차 I/O가 많습니다.

## 인덱스란?

인덱스는 데이터베이스에서 불필요한 조회를 방지하고 원하는 데이터를 효율적으로 조회할 수 있도록, 칼럼 값과 해당 데이터의 물리적 주소가 키와 값으로 매핑된 자료구조입니다.

프로그래밍 자료구조로 비유하면 데이터를 순차적으로 디스크에 저장하는 과정은 `ArrayList`와 유사하며, 인덱스는 특정 칼럼과 `ArrayList`의 인덱스 주소를 정렬한 `SortedList`와 유사합니다.

데이터를 정렬하여 보관하는 방식은 다양하며 크게 Hash 인덱스와 B-tree 인덱스로 구분합니다.

### Hash 인덱스와 B-Tree 인덱스 비교

+ **B-Tree 인덱스**는 키를 정렬하여 저장하는 구조로, 이진 트리 형태를 갖습니다. 이진 트리에서는 탐색을 위해 **키 값의 비교가 필요**하며, 이는 키 값을 **문자열 그대로 저장**하는 것과 관련이 있습니다. B-Tree는 키의 왼쪽부터 순서대로 비교하므로, 부분적으로 일치하는 키 값으로도 탐색이 가능합니다. 이러한 특성으로 B-Tree는 범위 검색에 유리합니다.

+ **Hash 인덱스**는 해시 함수를 사용하여 **키 값을 변환**하고 이를 해시 버킷에 저장합니다. 이러한 방식으로 인덱스를 구성하면 특정 값에 대한 **빠른 접근이 가능**하지만, 해시 함수의 특성상 일부분이 일치하는 키 값으로의 검색이 어렵습니다. 따라서 일치하는 키 값이 **전체적으로 일치해야만 정확한 조회**가 가능합니다.

> B-Tree 인덱스는 범위 검색에 유리하고, Hash 인덱스는 단일 키 값에 대한 빠른 조회에 유리합니다. 이를 통해 데이터베이스 설계 시 어떤 인덱스를 선택해야 할지를 고려할 수 있습니다.

## B-Tree 방식

B-Tree 인덱스는 Tree 구조에서 Balance(깊이)를 유지하는 트리 구조를 말합니다. Tree 구조와 B-Tree 구조를 이미지로 비교해 보았습니다.

| ![image.png](image.png) | ![image_1.png](image_1.png) |
|:-----------------------:|:---------------------------:|
|         편향 이진트리         |     B-tree ( Balance )      |

트리 구조에서 검색 속도는 화살표(브랜치:가지)의 수가 적을수록 빠릅니다. B-Tree 구조는 리프 노드의 깊이를 균형 잡힌 상태로 유지하기 때문에 검색 속도가 더 빠릅니다.

### 구조 및 특성

![image_2.png](image_2.png)

+ 최상위에 하나의 노드 (0009, 0018)을 **루트 노드(Root node)**
+ 중간 노드 (0003, 0006) 등을 **브랜치 노드(Branch node)**
+ 가장 하위에 있는 노드 (0001, 0002)를 **리프 노드 (Leaf node)**

인덱스의 리프 노드의 구조를 간단하게 표현하면 아래와 같습니다.

```java
public class LeafNode {
    private int nextIndexAddress; // 다음 인덱스의 메모리 주소
    private int prevIndexAddress; // 이전 인덱스의 메모리 주소
    private int indexValue; // 인덱스 값
    private int recordAddress; // 레코드 주소
}
```

MySQL InnoDB에서 사용하는 인덱스는 두 가지로 나누어집니다.

1. 프라이머리 키 인덱스
2. 세컨더리 인덱스(보조 인덱스)

**프라이머리 키 인덱스의 리프 노드**와 **세컨더리 인덱스의 리프 노드**는 큰 차이점이 있습니다.

1. 프라이머리 키 인덱스의 리프 노드는 레코드의 주소를 갖고 있습니다.
2. 세컨더리 인덱스의 리프 노드는 프라이머리 키의 값을 갖고 있습니다.

프라이머리 키 인덱스는 기본 키에 설정되는 인덱스가 되며, 보조 인덱스는 다른 컬럼인 날짜, 성별, 전화번호, 나이 등에 사용하는 인덱스를 말합니다.

내가 만약 보조 인덱스인 나이를 활용해서 검색을 했다면

1. **나이가 정렬된 트리 구조**로 인덱스가 존재합니다.
2. 나이로 정렬된 리프 노드에는 레코드 주소 대신에 **기본 키가 저장**되어있습니다.
3. **기본 키로 정렬된 트리 구조** 인덱스로 넘어갑니다.
4. 해당 인덱스 리프 노드에 **레코드 주소**가 있습니다.
5. 레코드 주소로 **데이터 파일을 찾아서 읽어옵니다.**

## 인덱스 키 추가 및 삭제

테이블의 레코드를 저장하거나 변경하는 경우 인덱스 키를 추가하거나 삭제하는

경우가 발생합니다.

어떻게 처리되는지 알아두면 쿼리의 성능도 예측할 수 있습니다.

### 인덱스 키 추가

1. 인덱스 추가 시 저장되는 Key 값으로 저장할 리프 노드 위치를 검색
2. 위치가 결정되면 레코드의 키 값과 주소 정보를 리프 노드에 저장
3. 리프 노드가 다 찰 경우 인덱스를 분리해야 하기 때문에 추가 비용 발생

인덱스 추가로 인해 INSERT나 UPDATE가 발생한다면 테이블을 저장하는데 발생하는 비용을 1이라고 한다면 인덱스당 추가 작업 비용이 1.5가 발생합니다. 테이블에 인덱스가 3개가 있다면 1 + (1.5 * 3) = 5.5의 비용이 발생됩니다.

💡 인덱스 추가, 변경 비용이 크기 때문에 InnoDB는 Change Buffer(변경 버퍼)를 사용합니다. 이 비용의 대부분이 메모리, CPU에서 처리하는 시간이 아니라 디스크로부터 인덱스 페이지를 읽고 쓰기를 해야 해서 걸리는 시간입니다.

[MySQL :: MySQL 8.0 Reference Manual :: MySQL Glossary](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_change_buffer)

### 인덱스 키 삭제

1. 해당 리프 노드를 찾아서 삭제 마킹(delete-marking)을 합니다.
2. 변경 버퍼(Change Buffer)에 변경 사항을 기록합니다.
3. 버퍼가 동작할 때 디스크에 삭제 마킹을 합니다.

### 인덱스 키 변경

> 인덱스의 키 값은 그 값에 따라 저장되는 리프 노드의 위치가 결정되기 때문에 키 값이 변경될 경우 인덱스 상의 키만 변경되는 것은 불가능합니다.
> 1. 변경 전 키 값을 삭제합니다. (인덱스 키 삭제와 동일)
> 2. 새로운 키 값을 저장합니다. (인덱스 키 추가와 동일)

### 인덱스 키 검색 시 주의사항

> InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키락은 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현되어 있습니다.
> 쉽게 말한다면 InnoDB 엔진에서 데이터를 수정하려면 해당 데이터의 물리적 위치에 대한 정보가 필요합니다. 인덱스가 없는 경우 WHERE 절에 범위를 지정하더라도 모든 레코드를 차례로 검색하면서 조건을 만족하는 레코드를 찾아야 합니다. 이렇게 모든 레코드를 하나씩 점검하는 과정에서 변경하려는 레코드를 찾을 때까지 다른 트랜잭션들도 해당 테이블의 레코드에 대한 레코드 락을 기다리게 됩니다.
> 인덱스가 없는 경우에는 모든 레코드에 대한 레코드 락이 설정되어 있어 다른 트랜잭션들도 기다려야 합니다. 이러한 현상을 데드락이라고도 부르며, 동시성 문제를 일으키는 일반적인 상황 중 하나입니다.

### 인덱스 키 값의 크기

> 디스크에 데이터를 저장하는 가장 기본 단위를 페이지라고 하는데 인덱스도 마찬가지로 페이지 단위로 관리합니다. 이진트리와 다르게 B-Tree는 자식 노드의 개수가 가변적인 구조이기 때문에 자식 노드의 개수는 페이지 크기와 연관이 됩니다.

💡 기본 인덱스 페이지는 16KB입니다. 인덱스 데이터 하나에 인덱스 값과 해당 레코드 주소를 저장해야 한다면 인덱스 값의 바이트와 레코드 주소 바이트가 인덱스 레코드 정보가 됩니다. 페이지 크기 / 인덱스 레코드당 바이트 크기 16 * 1024 / (16 + 12) = 585개가 됩니다. 페이지 16KB당 자식 노드는 585개를 가질 수 있는 B-Tree 인덱스 페이지가 됩니다.

💡 인덱스 값의 크기가 커질수록 자식 노드의 개수는 감소하고 인덱스 값의 크기가 커질수록 필요한 디스크 페이지도 커집니다.

> 페이지가 많아진다는 것은 조회 쿼리가 레코드 500개를 읽는다면 필요한 인덱스 페이지 수가 증가한다는 의미입니다. 그만큼 디스크 I/O 횟수가 증가하게 되고, 그만큼 느려진다는 의미입니다.

### 선택도(기수성)

> 선택도(Selectivity) 또는 기수성(Cardinality)는 거의 같은 의미로 사용되며 전체 인덱스 키 값에서 유니크한 값의 수를 의미합니다. 전체 인덱스 값이 100개, 유니크한 인덱스 값이 10개라면 기수성은 10이 됩니다.

💡 인덱스 키 값 가운데 중복된 값이 많아지면 많아질수록 기수성은 낮아지고 동시에 선택도 또한 떨어집니다.

> 선택도가 높을수록 검색대상이 줄기 때문에 그만큼 빠르게 처리됩니다. 그렇다고 선택도가 낮다고 해도 인덱스를 정렬이나 그루핑과 같은 작업을 위해 인덱스를 설정하는 경우도 있습니다.

### 인덱스가 검색 속도가 빠르니까 무조건 사용하는 게 좋을까요?

> 아닙니다. 인덱스를 통해서 레코드의 정보를 가져오기 위해서 보조 인덱스 트리도 타고, 기본 키 인덱스도 타고 그리고 읽어오는 과정이 생깁니다. 단건일 경우에는 인덱스로 조회하는 게 빠를 수 있으나 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고, 테이블을 모두 읽어서 필요한 레코드만 가려내는 방식이 더 효율적입니다. 이렇게 될 경우 MySQL 옵티마이저가 기본적으로 테이블을 읽는 방식으로 처리합니다.

### 인덱스를 통한 데이터 읽기

> 어떤 경우에 인덱스를 사용하게 할지, 사용 못하게 할지 판단하기 위해 내부에서 인덱스로 실제 레코드를 읽어내는지 알아야 합니다.

## 인덱스 레인지 스캔

💡 **전제조건**

1) 인덱스의 범위가 결정되었을 때 사용된다.
2) 인덱스가 사용되어야 한다.

> 인덱스의 범위가 지정되면 시작하는 인덱스를 찾으면 그때부터 리프 노드의 레코드만 순서대로 읽습니다. 하지만 보조 인덱스는 정렬과 상관없이 데이터 저장 순서와는 상관이 없기 때문에 레코드 한 건 단위로 랜덤 I/O가 발생하게 됩니다.

> 순서
1. 인덱스 조건에 만족하는 리프 노드를 찾는데 이 과정을 인덱스 탐색이라 한다.
2. 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 읽는다. 이 과정을 인덱스 스캔이라 한다.
3. 읽은 인덱스 키와 레코드 주소를 이용해 저장된 페이지를 가져오고 최종 레코드를 읽어옵니다.

### 커버링 인덱스

💡 **쿼리를 충족**시키는데 필요한 모든 데이터를 갖고 있는 인덱스를 말합니다. 인덱스 컬럼에 있는 컬럼만 가지고 조회하기 때문에 레코드까지 접근할 필요가 없습니다.

> 쿼리를 충족시킨다는 것은 필요한 컬럼이 인덱스 내부에서 해결될 때를 말합니다. 인덱스 컬럼이 (이름, 나이, 성별)이라고 할 때 조회 컬럼을 SELECT 이름, 나이, 성별로 할 경우 이미 인덱스에 데이터가 있기 때문에 레코드까지 접근할 필요가 없습니다.

## 인덱스 풀 스캔

💡 **전제조건**

1) 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우 사용된다.
> 인덱스 컬럼 (이름, 나이, 성별)이 순서대로 저장된 인덱스라고 할 때 WHERE 나이, 성별로 조건을 걸 경우 선두 컬럼인 이름이 없기 때문에 이때에는 인덱스 풀 스캔이 됩니다. 만약 커버링 인덱스일 경우에는 인덱스 풀 스캔이 테이블 풀 스캔보다 낫습니다. 하지만 이 방식은 인덱스를 사용하지 못한다, 인덱스를 효율적으로 사용하지 못한다는 표현을 사용합니다.

## 루스 인덱스 스캔

💡 **전제조건**
1. 단일 테이블 대상
2. GROUP BY, MIN, MAX를 사용할 경우
3. GROUP BY에서는 인덱스 컬럼의 순서가 지켜져야 하고 인덱스에 없는 컬럼이 들어올 경우 적용 안됩니다.
> 중간에 필요하지 않은 인덱스는 무시하고 필요한 인덱스 처음이나 끝만 읽고 넘어갑니다.

## 인덱스 스킵 스캔

💡 **전

제조건**
1) SET optimizer_switch=’skip_scan=on’;
2) 인덱스의 선두 컬럼의 유니크 값의 개수가 적어야 합니다.
3) 커버링 인덱스에 해당해야 합니다.

> 만약 커버링 인덱스가 아니라 모든 컬럼을 읽을 경우에는 인덱스 스킵 스캔을 사용하지 못하고 풀 테이블 스캔이 될 수 있습니다.

## 다중 칼럼 인덱스

> 인덱스는 선행 컬럼, 컬럼의 앞글자처럼 왼쪽을 기준으로 정렬되고 그 기준을 의존하여 두 번째 인덱스 컬럼이 정렬이 됩니다. 다중 컬럼 인덱스일 경우에는 인덱스 컬럼의 순서가 중요하고 단일 컬럼일 경우에도 앞글자가 포함되어 있어야 합니다.

## 인덱스 정렬 및 스캔 방향

+ **오름차순 인덱스(Ascending index)**
   ```sql
   CREATE INDEX ix_firstname_asc ON employees (first_name ASC);
   ```
  작은 값의 인덱스 키가 B-tree 왼쪽으로 정렬된 인덱스
    + "A" -> "B" -> "C"

+ **내림차순 인덱스(Descending index)**
   ```sql
   CREATE INDEX ix_firstname_desc ON employees (first_name DESC);
   ```
  큰 값의 인덱스 키가 B-tree 왼쪽으로 정렬된 인덱스
    + "C" -> "B" -> "A"

#### first_name을 오름차순 인덱스로 사용한다면

```sql
SELECT * FROM employees ORDER BY first_name DESC LIMIT 10;
```

+ 페이지 내에서 인덱스 레코드는 단방향으로 연결된 구조
+ 페이지 잠금이 인덱스 정순 스캔(Forward index scan)에 적합한 구조

+ ![image_3.png](image_3.png)
+ [출처-카카오](https://tech.kakao.com/posts/351)

#### 정리

InnoDB 스토리지 엔진에서는 내부적으로 페이지의 레코드를 접근할 때마다, 페이지에 대해서 잠금을 걸어야 합니다. 이때 InnoDB 스토리지 엔진은 RW-lock(Semaphore)이 아닌 Mutex를 사용하기 때문에 읽기 쿼리와 쓰기 쿼리뿐만 아니라 읽기 쿼리들끼리도 페이지 잠금을 점유하기 위해서 경쟁해야 하기 때문에, 동시 쓰레드가 많아지면 많아질수록 성능 영향도는 더 커지게 됩니다.

+ 데이터가 소량이라면 큰 차이가 없다.
+ 데이터베이스에서 매번 Disk에서 읽어오는 거라면 양방향 이동이 가능하므로 ASC, DESC도 차이가 없다.
+ InnoDB 페이지 수준에서 대량 조회라면 고려해야 한다.

### 인덱스의 가용성과 효율성

+ **가용성(Availability)**
    + 데이터베이스 시스템이 이를 효과적으로 활용할 수 있다는 것을 의미
+ **효율성(Efficiency)**
    + 데이터베이스 시스템이 인덱스를 효율적으로 사용되는지를 의미

인덱스를 사용하여 데이터를 조회할 때 작업의 범위를 결정하는 것을 **작업 범위 결정 조건**이라고 하며, 거름 종이 역할만 하는 것을 **필터링 조건**이라고 합니다.

인덱스는 단일 컬럼 인덱스나 복합 컬럼 인덱스 모두 왼쪽 칼럼을 기준으로 정렬 후 다음 칼럼이 정렬됩니다.

```sql
케이스 A : INDEX (age, gender)
케이스 B : INDEX (gender, age)
```

+ 인덱스 A는 나이로 정렬된 후 나이 내에 성별로 정렬이 됩니다.
+ 인덱스 B는 성별을 기준으로 정렬된 후 성별 내에 나이 칼럼이 정렬됩니다.

만약 데이터를 조회할 때 남성, 20세 이상을 조회한다면 인덱스 B가 효율성이 좋습니다. 인덱스 A의 gender는 `필터링` 조건으로 건에 일치 여부를 확인 용도로만 사용되기 때문입니다.

### 인덱스를 사용하지 못하는 경우

1. **NOT-EQUAL 비교**:
    - 비교 연산자가 NOT-EQUAL(`!=` 혹은 `<>`)로 사용된 경우, 인덱스의 활용이 제한됩니다.

2. **LIKE '%??' 비교**:
    - 문자열 패턴을 뒷부분 일치로 비교하는 경우(`LIKE '%??'`), 인덱스의 활용이 어려울 수 있습니다.

3. **스토어드 함수나 다른 연산자 사용**:
    - 인덱스 컬럼이 스토어드 함수나 다른 연산자를 통해 변형된 후 비교되는 경우, 인덱스의 활용이 어려울 수 있습니다.
    - 예: `WHERE DAYOFMONTH(column) = 1`, `WHERE SUBSTRING(column, 1, 1) = 'X'`

4. **NOT-DETERMINISTIC 함수 사용**:
    - NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우, 인덱스의 활용이 어려울 수 있습니다.
    - 이는 함수의 결과가 항상 동일하지 않을 수 있기 때문입니다.

5. **다른 데이터 타입 비교**:
    - 데이터 타입이 서로 다른 경우에는 인덱스 컬럼을 변환해야만 비교가 가능하며, 이는 인덱스의 활용을 제한할 수 있습니다.
    - 예: `WHERE char_type_column = 10`

6. **문자열 콜레이션의 차이**:
    - 문자열 데이터 타입의 콜레이션(collation)이 다른 경우에는 인덱스의 활용이 어려울 수 있습니다.
    - 예: `WHERE utf8_column = euckr_column`

> MySQL은 다른 RDBMS와 다르게 NULL 값도 인덱스에 저장됩니다.

말씀해주셔서 감사합니다. 아래는 해당 부분을 좀 더 자세히 설명한 내용입니다:

### 인덱스를 사용하려면

1. **동등 비교 (Equality Comparison)**
    - 인덱스가 가장 효율적으로 사용되는 경우는 `=` 연산자를 사용하는 동등 비교입니다. 예를 들어, `WHERE column = value`와 같은 조건은 인덱스를 통해 해당 값을 빠르게 찾을 수 있게 합니다. 동등 비교는 데이터베이스가 인덱스의 구조를 사용하여 특정 값을 빠르게 조회할 수 있도록 합니다.
    ```sql
    SELECT * FROM employees WHERE last_name = 'Smith';
    ```

2. **크다 작다 비교 (Range Comparison)**
    - 인덱스는 `>`, `<`, `>=`, `<=` 연산자와 같은 크다 작다 비교에도 유용합니다. 이러한 비교 연산자는 인덱스의 정렬된 특성을 활용하여 범위 내의 값을 빠르게 찾을 수 있게 합니다. 예를 들어, 특정 범위의 데이터를 검색할 때 유용합니다.
    ```sql
    SELECT * FROM employees WHERE salary > 50000;
    SELECT * FROM employees WHERE birth_date BETWEEN '1980-01-01' AND '1990-12-31';
    ```

3. **LIKE로 좌측 일치 패턴 (Left Anchored Pattern with LIKE)**
    - `LIKE` 연산자는 문자열 검색을 위해 사용되며, 인덱스는 특히 패턴이 문자열의 처음부터 일치하는 경우에 효과적입니다. 예를 들어, `LIKE 'prefix%'`와 같은 조건은 인덱스를 사용하여 효율적으로 검색할 수 있습니다. 그러나 `LIKE '%suffix'`와 같이 패턴이 뒷부분에 있는 경우에는 인덱스를 사용할 수 없습니다.
    ```sql
    SELECT * FROM employees WHERE first_name LIKE 'J%';
    ```