# Collection-List  
  
--- 
마지막 수정일 2024-06-14  
  
## 리스트를 사용하는 이유
정적 배열과 다르게 `List` 인터페이스를 구현한 컬렉션들은 요소 추가/삭제/탐색/검색에 대한 다양한 메서드를 제공합니다. 
특정 상황에 맞는 성능 특성을 가진 리스트를 선택할 수 있으며 요소가 추가된 순서를 유지하므로, 순차적으로 데이터를 관리할 수 있습니다.

## 키워드 
1. **동적배열** (Dynamic Array) - `ArrayList`는 동적 배열을 사용하여 요소를 저장합니다.
2. **순서유지** (Ordered) - `List`는 삽입된 순서를 유지합니다.
3. **중복허용** (Allows Duplicates) - `List`는 중복된 요소를 허용합니다.
4. **인덱스 접근** (Index Access) - `List`는 요소에 인덱스로 접근할 수 있습니다.
5. **삽입/삭제** (Insertion/Deletion) - `List`는 요소의 삽입과 삭제를 지원합니다.
6. **성능특성** (Performance Characteristics) - `ArrayList`와 `LinkedList`는 삽입, 삭제, 접근에 대한 성능 특성이 다릅니다.
7. **타입안전성** (Type Safety) - 제네릭을 통해 타입 안전성을 제공합니다.
  
## 구현체  

### ArrayList
- **내부 구조:** 동적 배열
- **특징:**
    - 요소에 대한 인덱스 접근이 빠름 (`O(1)`)
    - 요소 삽입/삭제가 느림 (`O(n)`), 특히 중간에 삽입/삭제 시
- **동기화:** 비동기화 (스레드 안전하지 않음)
- **사용 예:** 읽기 작업이 많고, 삽입/삭제가 적은 경우

```java
List<String> arrayList = new ArrayList<>();
arrayList.add("Apple");
arrayList.add("Banana");
System.out.println(arrayList.get(0)); // Apple
```

### LinkedList
- **내부 구조:** 이중 연결 리스트
- **특징:**
    - 요소에 대한 인덱스 접근이 느림 (`O(n)`)
    - 인덱스 접근 기능이 있지만 처음부터 탐색하거나 맨 뒤에서부터 탐색하는 방식이기 때문
    - 요소 삽입/삭제가 빠름 (`O(1)`), 리스트의 중간에 삽입/삭제 시에도 효율적
- **동기화:** 비동기화 (스레드 안전하지 않음)
- **사용 예:** 삽입/삭제 작업이 빈번하고, 인덱스 접근이 적은 경우

```java
List<String> linkedList = new LinkedList<>();
linkedList.add("Apple");
linkedList.add("Banana");
System.out.println(linkedList.get(0)); // Apple
```

### Vector
- **내부 구조:** 동적 배열 (ArrayList와 유사)
- **특징:**
    - 요소에 대한 인덱스 접근이 빠름 (`O(1)`)
    - 요소 삽입/삭제가 느림 (`O(n)`), 특히 중간에 삽입/삭제 시
    - 동기화 (스레드 안전)
- **동기화:** 동기화됨 (스레드 안전)
- **사용 예:** 여러 스레드에서 안전하게 사용해야 하는 경우

```java
List<String> vector = new Vector<>();
vector.add("Apple");
vector.add("Banana");
System.out.println(vector.get(0)); // Apple
```

### 주요 차이점 요약
| 특성     | ArrayList    | LinkedList    | Vector                   |
|--------|--------------|---------------|--------------------------|
| 내부 구조  | 동적 배열        | 이중 연결 리스트     | 동적 배열                    |
| 인덱스 접근 | 빠름 (`O(1)`)  | 느림 (`O(n)`)   | 빠름 (`O(1)`)              |
| 삽입/삭제  | 느림 (`O(n)`)  | 빠름 (`O(1)`)   | 느림 (`O(n)`)              |
| 동기화    | 비동기화         | 비동기화          | 동기화                      |
| 사용 예   | 읽기 작업이 많은 경우 | 삽입/삭제가 빈번한 경우 | 여러 스레드에서 안전하게 사용해야 하는 경우 |

이러한 특성을 바탕으로 각 상황에 맞는 `List` 구현 클래스를 선택하여 사용하면 됩니다.  
  
## 비교 

### 순서유지 방식
`ArrayList`는 내부적으로 동적 배열을 사용하여 데이터를 저장합니다. 
중간 데이터를 삭제한다면 다음과 같은 로직을 수행합니다.  
  
1. 삭제된 요소의 다음 인덱스부터 끝까지의 모든 요소를 한 칸씩 앞으로 이동시킵니다.
2. 마지막 요소의 인덱스는 빈 공간이 되어 `size`를 하나 줄입니다.  
    
```Java
final int newSize;
if ((newSize = size - 1) > i)
    System.arraycopy(es, i + 1, es, i, newSize - i);
es[size = newSize] = null;
```
이 과정을 통해 `ArrayList`는 순서를 유지합니다. 선입선출(`FIFO`)로 사용할 수 없는 구조입니다.   
  
`LinkedList`는 이중 연결 리스트를 사용하여 데이터를 저장합니다.  
첫 번째 인덱스의 데이터를 삭제한다면 다음과 같은 로직을 수행합니다.
1. 노드 삭제 시, 삭제할 노드의 이전 노드가 삭제할 노드의 다음 노드를 가리키도록 합니다.
2. 삭제할 노드의 다음 노드가 삭제할 노드의 이전 노드를 가리키도록 합니다.  
  
`ArrayList`보다 간단하게 순서를 유지할 수 있으므로, 선입선출(`FIFO`)로 사용할 수 있습니다.
  
### 배열확장시
`ArrayList`는 배열의 공간이 여유가 있는 경우 요소를 추가하고 `size`를 1 증가시킵니다. 
배열에 여유 공간이 없는 경우, 기존 배열의 크기의 1.5배 또는 2배의 크기를 늘려 새 배열을 생성하는 과정이 있습니다.  
+ 평균 시간 복잡도: O(1) (단, 배열 크기를 늘리는 경우 O(n))  
  
`LikedList`는 `new Node()`를 생성하여 마지막 노드의 다음 노드로 연결하고 새로운 노드의 이전 노드로 
마지막 노드를 설정합니다. 
+ 평균 시간 복잡도: O(1)  
  
`addAll(n)`과 같이 컬렉션를 삽입하는 경우에는 두 구현체 모두 `O(n)`의 시간복잡도를 갖습니다.
다만, `ArrayList`는 필요 시 배열 크기를 한 번만 변경하기 때문에 크기 변경이 빈번하지 않다면 성능이 더 나을 수 있습니다.

### 메모리 낭비  

`ArrayList`는 배열 크기를 늘릴 때 기존 배열에서 새로운 배열로 요소를 복사하는 과정에서 사용되지 않는 여유 공간이 생길 수 있습니다.
```java
List<String> arrayList = new ArrayList<>();
arrayList.add("Element1");
arrayList.add("Element2");
// 내부 배열이 가득 차면 더 큰 배열로 복사
```
`LinkedList`는 각 노드는 추가적인 메모리 오버헤드가 발생합니다. 노드 객체에는 데이터 외에도 두 개의 참조(링크) 변수가 포함됩니다.
```java
List<String> linkedList = new LinkedList<>();
linkedList.add("Element1");
linkedList.add("Element2");
// 각 요소가 노드로 추가됨
```
### 비교 요약
| 특성     | ArrayList                   | LinkedList             |
|--------|-----------------------------|------------------------|
| 내부 구조  | 동적 배열                       | 이중 연결 리스트              |
| 메모리 관리 | 배열 크기 증가 시 여유 공간 발생         | 각 노드에 추가적인 메모리 오버헤드 발생 |
| 메모리 낭비 | 배열 크기 증가 시 사용되지 않는 공간 발생 가능 | 노드당 추가적인 메모리 오버헤드 발생   |