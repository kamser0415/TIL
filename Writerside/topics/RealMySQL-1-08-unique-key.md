# 유니크 인덱스

> 유니크는 인덱스라기보다 제약 조건에 가까운데,
> NULL은 값이 아니기 때문에 2개 이상이 저장이 가능하다.

## 유니크 인덱스와 일반 세컨더리 인덱스의 비교

인덱스의 구조상 아무런 차이점이 없다.

### **인덱스 읽기**

인덱스 구조는 동일하기에 데이터의 중복 여부로 인해 읽어야 할 데이터 레코드가 많아져서 느린 것뿐이다.
1건의 레코드를 읽어야 하는 경우라면 실행 계획이 다르지만 읽어야 할 레코드 건수가 같다면 성능상의 차이는 미미하다.

### **인덱스 쓰기**

유니크 인덱스의 키 값을 쓸 때는 중복된 값이 있는지 없는지 체크하는 과정이 필요하다.
MySQL에서는 유니크 인덱스에서 중복된 값을 체크할 때는 읽기 잠금을 사용하고,
쓰기를 할 때는 쓰기 잠금을 사용하는데, 이 과정에서 데드락이 빈번하다.
인덱스를 저장할 때 저장할 위치를 검색하고 해당 위치에 저장하기에 비용이 크다.
그래서 InnoDB 스토리지 엔진은 체인지 버퍼로 효율적으로 관리하지만,
유니크 인덱스는 반드시 중복을 체크해야 하기에 작업 자체를 버퍼링하지 못한다.

## 유니크 인덱스 사용 시 주의사항

더 성능이 좋아질 것으로 생각하고 불필요하게 유니크 인덱스를 생성하지 않는 것이 좋다.
유니크 인덱스도 일반 세컨더리 인덱스와 같은 역할을 하기에 중복으로 인덱스를 생성할 필요가 없다.

## 수정 및 추가 설명

1. **NULL 값 허용**: 유니크 인덱스는 NULL 값을 허용할 수 있습니다. 다만, NULL 값은 서로 다른 값으로 취급되므로, 여러 개의 NULL 값이 유니크 인덱스에 포함될 수 있습니다. 이를 정확하게 이해해야 합니다.

2. **인덱스 읽기 성능**: 유니크 인덱스와 일반 인덱스는 데이터 구조 자체는 동일하지만, 유니크 인덱스는 중복 검사를 위해 추가적인 조건을 고려해야 할 수 있습니다. 따라서 대량의 데이터를 처리할 때는 성능 차이가 발생할 수 있습니다.

3. **데드락**: 유니크 인덱스에서의 읽기 잠금과 쓰기 잠금이 데드락을 유발할 수 있습니다. 이는 특히 트랜잭션이 복잡하게 얽혀 있는 경우 발생할 수 있으며, 이를 피하기 위한 최적화가 필요합니다.

4. **체인지 버퍼 사용**: InnoDB의 체인지 버퍼는 비유니크 인덱스의 변경 사항을 버퍼링하여 디스크 I/O를 줄입니다. 하지만 유니크 인덱스는 반드시 중복 체크를 수행해야 하므로 체인지 버퍼를 사용할 수 없습니다. 이는 유니크 인덱스의 쓰기 성능에 영향을 미칩니다.

5. **유니크 인덱스 사용의 최적화**: 유니크 인덱스는 데이터 무결성을 유지하는 데 유용하지만, 불필요한 유니크 인덱스를 추가하면 오히려 성능 저하를 초래할 수 있습니다. 따라서 꼭 필요한 경우에만 유니크 인덱스를 사용하는 것이 좋습니다.

## 예시

다음은 유니크 인덱스를 사용할 때의 예시입니다.

**유니크 인덱스 생성**

```sql
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    email VARCHAR(255),
    username VARCHAR(255),
    UNIQUE (email),
    UNIQUE (username)
);
```

이 예시에서는 `email`과 `username` 컬럼에 유니크 인덱스를 추가하여 중복된 값이 들어가지 않도록 합니다.

**유니크 인덱스 중복 체크**

```sql
INSERT INTO users (email, username) VALUES ('test@example.com', 'testuser');
-- 성공

INSERT INTO users (email, username) VALUES ('test@example.com', 'anotheruser');
-- 실패: email 중복

INSERT INTO users (email, username) VALUES ('another@example.com', 'testuser');
-- 실패: username 중복
```
