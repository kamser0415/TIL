# Collection-Basic

자바에서 컬렉션은 목록성 데이터를 처리하는 자료 구조를 말합니다.  
하나 이상의 데이터를 하나의 객체에 담아서 관리하는 자료구조를 `Data Structure`라고 합니다.

## 왜 프레임워크라고 할까
`프레임워크`라고 붙은 이유는 이미 만들어진 API로 사용자가 그 구조에 맞게 사용하기 때문입니다.  
컬렉션 프레임워크를 사용하는 이유는 데이터를 저장하고 처리하는 데 필요한 다양한 자료구조와 알고리즘을 표준화한 설계를 구체화하여 제공하기 때문입니다. 따라서 개발자는 모든 기능을 직접 개발하지 않고 필요한 부분만 재정의하여 사용할 수 있습니다.

## 배열과 컬렉션의 차이점
배열은 크기가 고정되어 있어 데이터를 얼마만큼 담을지 미리 알기 어려운 경우에는 별도의 메서드를 만들어서 관리해야 합니다. 반면 컬렉션은 크기가 동적으로 변경될 수 있어 이러한 불편함을 해결해 줍니다.

자바에서 데이터를 담는 주요 자료구조는 다음과 같습니다:
1. **List**: 순서가 있는 데이터 구조 (예: `ArrayList`, `LinkedList`)
2. **Set**: 순서가 중요하지 않은 데이터 구조, 중복 허용하지 않음 (예: `HashSet`, `TreeSet`)
3. **Queue**: FIFO(First-In-First-Out) 구조 (예: `LinkedList`, `PriorityQueue`)
4. **Map**: 키-값으로 이루어진 데이터 구조 (예: `HashMap`, `TreeMap`)

컬렉션은 `List`, `Set`, `Queue`가 `Collection` 인터페이스를 구현했습니다.  
그러면 `Collection` 인터페이스는 어떤 기능을 제공하길래 `Map`은 구현하지 못했을까요?

## Collection 인터페이스와 Map 인터페이스의 차이
`Collection` 인터페이스는 순서나 집합 개념을 가진 데이터의 모음을 다룹니다. 반면 `Map` 인터페이스는 키를 통한 빠른 검색과 키 데이터의 유일성을 보장하는 구조로 설계되어 있어, 서로 다른 인터페이스로 구분됩니다.

하지만 `Map` 인터페이스를 구현한 클래스 내부에 `Iterator`를 상속한 정적 멤버 클래스를 활용하여 데이터를 순차적으로 읽어올 수 있습니다.

## 주요 차이점
- **컬렉션**: 객체 자체의 참조 값으로 저장하는 구조
- **맵**: 특정 키를 가지고 값을 저장하는 구조

## Iterator와 Collection의 기능 및 목적

### Iterator 인터페이스
`Iterator` 인터페이스는 컬렉션 요소들을 순차적으로 접근하기 위한 방법을 제공합니다. 이를 통해 컬렉션 내부를 순회(navigation)할 수 있습니다.

#### 주요 메소드
- `boolean hasNext()`: 다음 요소가 있는지 확인합니다.
- `E next()`: 다음 요소를 반환합니다.
- `void remove()`: 마지막으로 반환된 요소를 제거합니다 (선택적).

### Collection 인터페이스 {id="collection_1"}
`Collection` 인터페이스는 여러 요소를 그룹으로 다루기 위한 기본 인터페이스로, `Iterator`를 확장하여 다양한 추가 기능을 제공합니다. 이는 데이터를 추가, 삭제, 검색, 변환하는 메소드들을 포함하여 컬렉션을 조작할 수 있는 더 광범위한 기능을 제공합니다.

## 각 자료구조의 사용 용도 및 한계

### Collection의 사용 용도
- **List**: 순서가 중요하고 중복을 허용하는 데이터 저장에 유리합니다. 예를 들어, 학생들의 점수를 저장하거나, 쇼핑 카트의 상품 목록을 관리하는 경우에 적합합니다.
    - **한계**: 대량의 데이터를 중간에 삽입하거나 삭제할 때 성능 저하가 발생할 수 있습니다. 이러한 한계는 연결 리스트인 `LinkedList`를 사용할 수 있습니다.

- **Set**: 중복을 허용하지 않는 데이터 저장에 유리합니다. 예를 들어, 유일한 사용자 ID를 저장하거나, 중복 없는 태그 목록을 관리하는 경우에 적합합니다.
    - **한계**: 요소의 순서를 보장하지 않으며, 특정 순서가 필요한 경우 `LinkedHashSet`이나 `TreeSet`을 사용할 수 있습니다.

- **Queue**: FIFO(First-In-First-Out) 구조가 필요한 작업 대기열에 유리합니다. 예를 들어, 프린터 작업 대기열이나, 고객 서비스 요청을 처리하는 경우에 적합합니다.
    - **한계**: 우선순위가 필요한 경우 `PriorityQueue`를 사용하여 우선순위 기반 큐를 구현할 수 있습니다.

### Map의 사용 용도 {id="map_1"}
- **HashMap**: 빠른 검색, 삽입, 삭제가 필요한 경우에 유리합니다. 예를 들어, 사용자 ID를 키로 하고 사용자 정보를 값으로 저장하는 경우에 적합합니다.
    - **한계**: 순서가 보장되지 않으며, 삽입 순서가 중요한 경우 `LinkedHashMap`을 사용할 수 있습니다.

- **TreeMap**: 키의 정렬된 순서가 필요한 경우에 유리합니다. 예를 들어, 사전순으로 정렬된 데이터를 저장하거나, 범위 검색이 필요한 경우에 적합합니다.
    - **한계**: 검색, 삽입, 삭제가 `HashMap`에 비해 느립니다. 이러한 한계는 성능과 정렬의 균형을 고려하여 선택해야 합니다.

## 한계와 해결책
- **동기화 문제**: 기본 컬렉션 클래스들은 동기화되지 않아서 멀티스레드 환경에서 안전하지 않습니다. 이러한 문제를 해결하기 위해 `Collections.synchronizedList`, `Collections.synchronizedSet`, `Collections.synchronizedMap` 등을 사용할 수 있습니다. 또한, `ConcurrentHashMap`, `CopyOnWriteArrayList` 등의 스레드 안전한 컬렉션을 사용할 수 있습니다.
- **메모리 사용**: 많은 데이터를 저장할 때 메모리 사용량이 문제가 될 수 있습니다. 필요 없는 데이터를 적시에 제거하고, 필요한 최소한의 데이터만 유지하는 등의 방법으로 메모리 사용을 관리할 수 있습니다.
- **성능 최적화**: 대량의 데이터를 다룰 때 성능 저하가 발생할 수 있습니다. 이 경우, 적절한 자료구조를 선택하고, 시간복잡도가 낮은 알고리즘을 사용하는 것이 중요합니다.

## 구현체별 시간복잡도
### List

#### ArrayList
- **자료구조**: 동적 배열
- **시간복잡도**:
    - **접근**: O(1)
        - 배열은 인덱스를 통해 직접 접근할 수 있기 때문에 시간복잡도가 O(1)입니다.
    - **탐색**: O(n)
        - 배열의 모든 요소를 순차적으로 탐색해야 하므로 O(n)입니다.
        - 인덱스로 접근이 아닐경우 `equals`로 탐색합니다.
    - **삽입**: O(n) (중간에 삽입할 경우), O(1) (맨 뒤에 삽입할 경우, 가끔 배열 재할당 필요)
        - 중간에 삽입 시 요소들을 이동해야 하므로 O(n)입니다. 맨 뒤에 삽입 시 배열의 크기를 넘지 않으면 O(1)입니다.
    - **삭제**: O(n)
        - 중간 요소를 삭제하면 나머지 요소들을 이동해야 하므로 O(n)입니다.
- **주의사항**: 동시성 문제가 발생할 수 있습니다. 이때는 Vector를 사용해야합니다. 

#### LinkedList
- **자료구조**: 이중 연결 리스트
- **시간복잡도**:
    - **접근**: O(n)
        - 인덱스를 통해 직접 접근할 수 없고 순차적으로 노드를 탐색해야 하기 때문에 O(n)입니다.
    - **탐색**: O(n)
        - 원하는 값을 찾기 위해 순차적으로 탐색해야 하므로 O(n)입니다.
    - **삽입**: O(n)
        - 특정 위치를 알고 있어도 접근후 삽입이므로 처음과 끝은 O(1) 중간 노드의 삽입은 O(n+1)이므로 O(n)입니다.
    - **삭제**: O(n)
        - 특정 위치를 알고 있어도 접근후 삭제이므로 처음과 끝은 O(1) 중간 노드의 삭제은 O(n+1)이므로 O(n)입니다.
- **주의사항**: 인덱스로 접근해도 내부에서는 절반의 노드를 순회합니다.

#### Vector
- **자료구조**: 동적 배열
- **시간복잡도**:
    - **접근**: O(1)
        - ArrayList와 동일하게 인덱스를 통해 직접 접근할 수 있습니다.
    - **탐색**: O(n)
        - 배열의 모든 요소를 순차적으로 탐색해야 하므로 O(n)입니다.
        - 인덱스로 접근이 아닐경우 `equals`로 탐색합니다.
    - **삽입**: O(n) (중간에 삽입할 경우), O(1) (맨 뒤에 삽입할 경우, 가끔 배열 재할당 필요)
        - ArrayList와 동일하게 중간에 삽입 시 요소들을 이동해야 하므로 O(n)입니다.
    - **삭제**: O(n)
        - 중간 요소를 삭제하면 나머지 요소들을 이동해야 하므로 O(n)입니다.

### Set

#### HashSet
- **자료구조**: 해시 테이블
- **시간복잡도**:
    - **탐색**: O(1)
        - 해시 함수를 통해 빠르게 요소에 접근할 수 있습니다.
    - **삽입**: O(1)
        - 해시 함수를 통해 요소를 빠르게 삽입할 수 있습니다.
    - **삭제**: O(1)
        - 해시 함수를 통해 요소를 빠르게 삭제할 수 있습니다.
- 해시 테이블의 성능은 해시 함수의 품질과 충돌 관리 방법에 따라 달라질 수 있습니다.

#### LinkedHashSet
- **자료구조**: 해시 테이블 + 이중 연결 리스트
- **시간복잡도**:
    - **탐색**: O(1)
        - 해시 함수를 통해 빠르게 요소에 접근할 수 있습니다.
    - **삽입**: O(1)
        - 해시 함수를 통해 요소를 빠르게 삽입할 수 있습니다.
    - **삭제**: O(1)
        - 해시 함수를 통해 요소를 빠르게 삭제할 수 있습니다.
- LinkedHashSet은 추가로 이중 연결 리스트를 사용하여 삽입 순서를 유지합니다.

#### TreeSet
- **자료구조**: Red-Black 트리
- **시간복잡도**:
    - **탐색**: O(log n)
        - 트리의 높이에 따라 탐색 시간이 결정됩니다.
    - **삽입**: O(log n)
        - 트리의 높이에 따라 삽입 시간이 결정됩니다.
    - **삭제**: O(log n)
        - 트리의 높이에 따라 삭제 시간이 결정됩니다.
- Red-Black 트리는 항상 균형을 유지하여 O(log n)의 시간복잡도를 보장합니다.

### Queue

#### PriorityQueue
- **자료구조**: 힙 (보통 이진 힙)
- **시간복잡도**:
    - **삽입**: O(log n)
        - 힙 구조에서 요소를 삽입할 때 트리의 높이에 따라 재구성해야 합니다.
    - **삭제**: O(log n) (최소/최대 원소 삭제)
        - 힙의 루트 요소를 삭제한 후 힙을 재구성해야 합니다.
    - **탐색**: O(n)
        - 힙에서는 특정 값을 찾기 위해 모든 요소를 탐색해야 할 수 있습니다.

#### LinkedList (Queue로서 사용)
- **자료구조**: 이중 연결 리스트
- **시간복잡도**:
    - **삽입**: O(1)
        - 양 끝에서 삽입 시 O(1)입니다.
    - **삭제**: O(1)
        - 양 끝에서 삭제 시 O(1)입니다.
    - **탐색**: O(n)
        - 특정 값을 찾기 위해 순차적으로 탐색해야 합니다.

### Map

#### HashMap
- **자료구조**: 해시 테이블
- **시간복잡도**:
    - **탐색**: O(1)
        - 해시 함수를 통해 빠르게 키에 접근할 수 있습니다.
    - **삽입**: O(1)
        - 해시 함수를 통해 키-값 쌍을 빠르게 삽입할 수 있습니다.
    - **삭제**: O(1)
        - 해시 함수를 통해 키-값 쌍을 빠르게 삭제할 수 있습니다.

#### LinkedHashMap
- **자료구조**: 해시 테이블 + 이중 연결 리스트
- **시간복잡도**:
    - **탐색**: O(1)
        - 해시 함수를 통해 빠르게 키에 접근할 수 있습니다.
    - **삽입**: O(1)
        - 해시 함수를 통해 키-값 쌍을 빠르게 삽입할 수 있습니다.
    - **삭제**: O(1)
        - 해시 함수를 통해 키-값 쌍을 빠르게 삭제할 수 있습니다.
- LinkedHashMap은 추가로 이중 연결 리스트를 사용하여 삽입 순서를 유지합니다.

#### TreeMap
- **자료구조**: Red-Black 트리
- **시간복잡도**:
    - **탐색**: O(log n)
        - 트리의 높이에 따라 탐색 시간이 결정됩니다.
    - **삽입**: O(log n)
        - 트리의 높이에 따라 삽입 시간이 결정됩니다.
    - **삭제**: O(log n)
        - 트리의 높이에 따라 삭제 시간이 결정됩니다.
- Red-Black 트리는 항상 균형을 유지하여 O(log n)의 시간복잡도를 보장합니다.

#### Hashtable
- **자료구조**: 해시 테이블
- **시간복잡도**:
    - **탐색**: O(1)
        - 해시 함수를 통해 빠르게 키에 접근할 수 있습니다.
    - **삽입**: O(1)
        - 해시 함수를 통해 키-값 쌍을 빠르게 삽입할 수 있습니다.
    - **삭제**: O(1)
        - 해시 함수를 통해 키-값 쌍을 빠르게 삭제할 수 있습니다.
- Hashtable은 동기화된 구조로, 멀티스레드 환경에서 안전합니다.
  
