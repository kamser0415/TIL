# 제네릭, 와일드 카드

## 날짜
2024-06-12

## 주제
+ 제네릭과 와일드 카드

## 내용    
   
### 제네릭
데이터 컨테이너와 같이 다른 클래스를 멤버 변수나 내부 필드에서 사용하려면 
필요한 클래스 타입마다 데이터 컨테이너를 타입별로 생성해야합니다. 
예를 들면 회원을 저장하는 동적배열 클래스, 주문을 저장하는 동적배열 클래스를 말합니다.  
  
매번 클래스를 사용하는 방법은 코드 재사용성이 떨어지고, 유지보수도 어려워집니다.  
자바의 다형성을 사용하여 공통으로 하나의 데이터 컨테이너를 만들고 `Object`로 데이터를 받는다면 
코드 재사용성도 높아지고, 불필요한 컨테이너 클래스를 만들지 않아도 됩니다.  
  
하지만, Object로 타입을 제한한 경우에는 모든 클래스 타입이 데이터 컨테이너에 삽입될 수 있으므로 
타입 안정성이 떨어지게 됩니다.  
  
타입 안정성이란 데이터 컨테이너에서 데이터를 꺼낼때 사용자가 생각한 타입으로 반환되어 
타입 체크를 하지 않고, 캐스팅을 하지 않고도 바로 사용할 수 있때를 말합니다. 
Object로 데이터 컨테이너를 만든다면 유연성은 높아지지만 데이터를 꺼낼때 어느 타입인지 타입 체크후 캐스팅이 필요합니다.  
  
1. 타입 안정성을 높이려면 컴파일시점에 타입이 지정되어야하며
2. 코드 유연성을 높이려면 클래스를 정의할때 타입이 지정되면 안됩니다.  
  
자바는 제네릭을 통해 두가지를 해결합니다.  
클래스나 메서드를 정의할 때는 타입 매개변수`<T>`를 사용하여 코드 유연성을 높이고, 
사용할때 타입 인자를 전달하여 타입 안정성을 보장합니다.   
  
### 와일드 카드  
와일드 카드는 제네릭과 유사합니다. 
제네릭은 호출할 때 타입 추론이 동작하여 반환 타입, 매개변수 타입을 제한한다면 와일드 카드는 타입 추론을 하지 않고 
이미 만들어진 제네릭 타입을 사용하는 것이 목적입니다.  
  
아래와 같은 코드는 와일드카드와 제네릭 메서드는 동일한 기능을 합니다.  
```Java  
// 제네릭
public <T extends Member> void make2(ArrayList<T> member) {
    System.out.println("회원 이름 : "+ member);
}
// 와일드카드
public void make1(ArrayList<? extends Member> member){
    System.out.println("회원 이름 : "+ member);
}
```  
타입 추론과 동작 방식에 의해서 다른 제네릭 클래스를 제한하거나 사용할 때는 와일드 카드를 사용하는 것을 권장하지만, 메서드의 파라미터로 직접 사용하거나 호출 시점에 반환 타입을 지정하려면 제네릭 메서드를 사용해야 합니다.
```Java
// 와일드카드
public void make1(? extends Member member){
    System.out.println("회원 이름 : "+ member);
}
// 반환타입
public <T extends Member> T make3(T member) {
    System.out.println("회원 이름 : " + member);
    return member;
}
```  
  
## 내일 학습할 예정
+ 와일드 카드가 제네릭 메서드보다 어떤 장점이 있어서 권장되는지 애매하게 알고 있습니다.
+ 제네릭 타입의 컴파일시 어떤 방식 인지 다시 확인해보려고합니다.
 